(()=>{"use strict";const e=require("socket.io"),n=require("uuid"),t=new e.Server(3e3);function s(){return(0,n.v4)()}console.log("Listening on *:3000"),t.sockets.on("connection",(e=>{console.log(`Connected ${e.id}`),e.on("requestLogin",((e,n)=>{console.log(`Login request for '${e.userID}'`),n(o.checkValidUser(e))})),e.on("requestRegister",((e,n)=>{console.log(`Register request for '${e}'`),n(o.generateAndRegisterNewUser(e))})),e.on("getRealm",((e,n)=>{n(o.getRealm(e.userID))})),e.on("disconnect",(()=>{console.log(`Disconnected ${e.id}`)}))}));class r{constructor(){this.entities={},this.users={},this.realms={}}checkValidUser(e){let n=this.users[e.userID];return null!=n&&n.auth.token==e.token}generateAndRegisterNewUser(e){if(null!=this.users[e])return{accepted:!1,reason:"Username already taken"};let t=function(e){const t={userID:e,token:(0,n.v4)()},r=function(e){return{uuid:s(),parent:void 0,name:e,items:[]}}(e);return{auth:t,player:r}}(e);return this.parentEntity(t.player,r.GLOBAL_REALM),console.log(`Registered new user '${e}'`),this.users[t.auth.userID]=t,{accepted:!0,userAuth:t.auth}}parentEntity(e,n){n.children.push(e)}getRealm(e){console.log(r.GLOBAL_REALM),console.log(JSON.stringify(r.GLOBAL_REALM))}}r.GLOBAL_REALM={uuid:s(),parent:void 0,name:"Void",owner:void 0,children:[]};const o=new r})();